generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum ProcessingStatus {
  PENDING
  PROCESSED
  ERROR
}

enum TransactionType {
  PAYABLE
  RECEIVABLE
}

enum TransactionStatus {
  PENDING
  SETTLED
}

enum SourceType {
  DRIVE
  LOCAL
}

enum MatchType {
  EXACT
  CONTAINS
  REGEX
}

enum NormalizationScope {
  EXPENSE
  INCOME
  BOTH
}

enum CategorySource {
  RAW
  NORMALIZED
  MANUAL
}

model SourceFile {
  id             String           @id @default(cuid())
  driveFileId    String           @unique
  name           String
  parentFolderId String?
  modifiedTime   DateTime
  checksum       String?
  processedAt    DateTime?
  status         ProcessingStatus @default(PENDING)
  errorMessage   String?
  source         SourceType       @default(LOCAL)
  transactions   Transaction[]

  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
}

model Transaction {
  id             String            @id @default(cuid())
  type           TransactionType
  
  // Relacionamento com o arquivo de origem
  sourceFileId   String
  sourceFile     SourceFile        @relation(fields: [sourceFileId], references: [id], onDelete: Cascade)

  // Campos de Negócio
  externalId     String?           // Número do Lançamento
  rowHash        String?           @unique // Hash para deduplicação (sourceFileHash + sheet + row + date + amount + desc)
  category       String?
  counterparty   String?           // Fornecedor ou Cliente
  description    String?
  unit           String?           // Unidade

  // Datas
  plannedDate    DateTime?         // Data Prevista / Vencimento Original
  dueDate        DateTime?         // Data Vencimento (considerada para fluxo)
  actualDate     DateTime?         // Data Pagamento / Recebimento

  // Valores
  plannedAmount  Decimal           @db.Decimal(12, 2) // Valor Original / Previsto
  actualAmount   Decimal?          @db.Decimal(12, 2) // Valor Pago / Baixado
  feesInterest   Decimal?          @db.Decimal(12, 2) // Juros/Multa
  feesFine       Decimal?          @db.Decimal(12, 2) 
  discount       Decimal?          @db.Decimal(12, 2)
  grossAmount    Decimal?          @db.Decimal(12, 2) // Valor Bruto

  status         TransactionStatus @default(PENDING)
  
  rawJson        Json?             // Dados originais da linha para debug

  // Campos de normalização de categoria
  rawLabel            String?         // Texto usado para matching de regras (derivado do import)
  categorySource      CategorySource  @default(RAW)
  normalizedByRuleId  String?         // FK para regra que categorizou
  normalizedByRule    CategoryNormalizationRule? @relation(fields: [normalizedByRuleId], references: [id], onDelete: SetNull)
  normalizedAt        DateTime?       // Quando a normalização foi aplicada

  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt

  @@index([externalId])
  @@index([type, dueDate])
  @@index([type, actualDate])
  @@index([sourceFileId])
  @@index([categorySource])
  @@index([normalizedByRuleId])
}

// ============================================================================
// CATEGORY NORMALIZATION
// ============================================================================

model CategoryNormalizationRule {
  id            String              @id @default(cuid())
  fromPattern   String              // Padrão a ser buscado (texto ou regex)
  matchType     MatchType           @default(CONTAINS)
  scope         NormalizationScope  @default(BOTH)
  toCategory    String              // Categoria de destino (nome padronizado)
  priority      Int                 @default(0)
  active        Boolean             @default(true)
  
  // Auditoria
  transactions  Transaction[]       // Transações normalizadas por esta regra
  
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  @@index([active, scope])
  @@index([priority])
}